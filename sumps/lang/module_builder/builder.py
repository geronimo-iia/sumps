from __future__ import annotations

import ast
import builtins
import logging
import re
import uuid
from datetime import datetime
from functools import lru_cache
from inspect import Signature
from io import StringIO, TextIOBase
from types import ModuleType
from typing import Any, TypeVar, cast

from ..symbols import (
    FunctionSymbol,
    LocalSymbolTable,
    ModuleSymbol,
    Statement,
    SymbolReference,
)
from .dynamic import DynamicModule
from .environment import GlobalEnvironmentBuilder
from .visitor import CodeGeneratorVisitor

__all__ = ["ModuleBuilder"]

T = TypeVar("T", bound=TextIOBase)


@lru_cache
def _get_builtin_type_names() -> list[str]:
    """returns a list of builtin type name."""
    return [getattr(builtins, d).__name__ for d in dir(builtins) if isinstance(getattr(builtins, d), type)]


_BUILTIN_TYPE_NAMES = _get_builtin_type_names()


class ModuleBuilder(ModuleSymbol):
    """Builds dynamic Python modules from symbol definitions with code generation and execution."""

    _locals: LocalSymbolTable
    __slots__ = ModuleSymbol.__slots__ + ("_locals",)

    def __init__(self, name: str | None = None, docstring: str | None = None):
        self._locals = LocalSymbolTable()
        super().__init__(name=name if name else f"dynamic_{uuid.uuid4().hex}", docstring=docstring)

    @property
    def locals(self) -> LocalSymbolTable:
        return self._locals

    def _analyze_annotation(self, annotation: type[Any]) -> SymbolReference | None:
        """Analyse provided annotation and reference all necessary symbols."""
        if annotation is Signature.empty:  # ignore empty marker ("inspect._empty")
            return None
        s = re.findall("'([^']*)'", repr(annotation))
        if len(s) > 0:
            _qualified_name = s[0]
            if _qualified_name not in _BUILTIN_TYPE_NAMES:
                return self.references.add(symbol=SymbolReference(name=_qualified_name))
        return None

    def add_statement(self, stmt: Statement) -> ModuleBuilder:
        """Adds a statement and analyzes its type annotations for imports."""
        statement = super().statements.add(stmt)
        # update symbol table reference if needed
        match statement.kind:
            case "class":
                pass
            case "function":
                function = cast(FunctionSymbol, statement)
                signature = function.get_signature()
                # import type of parameters
                for param in signature.parameters:
                    self._analyze_annotation(signature.parameters[param].annotation)
                # import return type
                if signature.return_annotation != Signature.empty:
                    self._analyze_annotation(signature.return_annotation)
            case _:
                pass
        return self

    def encodes(self, output: T) -> T:
        """Generates Python code from symbols and writes to output stream."""
        output.write(f"# Generated by {self.__class__.__name__} at {datetime.now().isoformat()}\n")
        visitor = CodeGeneratorVisitor(output=output)
        self.accept(visitor=visitor)
        return output

    def build(self, use_current_context: bool = False, store_in_sys_modules: bool = False, debug_logger: logging.Logger | None = None) -> DynamicModule:
        """Builds and executes the module, returning a DynamicModule instance.

        Args:
            use_current_context: If True, uses current globals for execution environment.
            store_in_sys_modules: If True, registers module in sys.modules for import access.
            debug_logger: If provided, logs generated code using this logger.
        """
        # Start with a minimal global environment
        global_visitor = GlobalEnvironmentBuilder(use_current_context=use_current_context)

        # Step 1: Import all listed symbol table
        self.references.accept(global_visitor)

        # Step 2: Inject user-provided locals (if any)
        self._locals.accept(global_visitor)

        # Step 3: Parse and verify code
        code = self.encodes(output=StringIO()).getvalue()
        try:
            ast.parse(code, filename=self.name)
        except SyntaxError as e:
            text = e.text.strip() if e.text else ""
            raise SyntaxError(f"SyntaxError in {self.name} at line {e.lineno}, column {e.offset}:\n{text}\n{code}\nMessage: {e.msg}") from e

        # Step 4: Execute into a module
        dynamic_module = ModuleType(self.qualified_name)
        dynamic_module.__dict__.update(global_visitor.build())
        try:
            if debug_logger:
                debug_logger.debug(f"Generated code for {self.name}:\n{code}")
            exec(code, dynamic_module.__dict__)
        except Exception as e:
            raise RuntimeError(f"Error during code execution: {e}\nCode:\n{code}") from e

        return DynamicModule(module=dynamic_module, store_in_sys_modules=store_in_sys_modules)