import asyncio
import threading
import time
from collections.abc import Callable
from typing import Any

from curio import CancelledError, TaskTimeout, run, spawn
from curio.thread import ThreadQueue


class AsyncioCurioBridge:
    """
    
    Each Curio task running a coroutine is tracked in _task_map keyed by the asyncio future.
    When the asyncio task is cancelled, the cancellation handler looks up the Curio task and calls .cancel() on it safely inside Curioâ€™s event loop.
    The Curio coroutine receives CancelledError and stops.
    Timeout errors still propagate normally.
    The Curio worker keeps running indefinitely.

    Notes:

        - Worker pool support for multiple Curio workers to scale concurrent calls
        - Graceful shutdown of the Curio thread(s)

        - Maintains N Curio worker threads, each with their own queue and task map.
        - Uses round-robin dispatch to spread calls evenly across workers.
        - Uses a threading.Event to signal graceful shutdown.
        - Sends a None sentinel to unblock queue receives and exit loops cleanly.
        - shutdown() waits for all threads to exit.

        - The worker threads run their own independent Curio loops.
        - The shutdown method cleanly stops the workers; call it before program exit.
        - You can tune workers to your CPU and concurrency needs.
    """
    def __init__(self, workers: int = 1):
        self._workers = workers
        self._queues = [ThreadQueue() for _ in range(workers)]
        self._task_maps = [{} for _ in range(workers)]
        self._shutdown_events = [threading.Event() for _ in range(workers)]
        self._threads = [None] * workers
        self._lock = threading.Lock()
        self._next_worker = 0
        self._running = False

    def _start_worker_thread(self, idx: int):
        def thread_target():
            while not self._shutdown_events[idx].is_set():
                try:
                    run(self._curio_worker(idx))
                except Exception as e:
                    print(f"[Curio worker {idx}] Crashed with error: {e}")
                    if self._shutdown_events[idx].is_set():
                        break
                    print(f"[Curio worker {idx}] Restarting in 1 second...")
                    time.sleep(1)  # Backoff before restart

        t = threading.Thread(target=thread_target, daemon=True, name=f"curio-worker-{idx}")
        self._threads[idx] = t # type: ignore
        t.start()

    async def _curio_worker(self, idx: int):
        queue = self._queues[idx]
        task_map = self._task_maps[idx]
        shutdown_event = self._shutdown_events[idx]

        while not shutdown_event.is_set():
            # Try to recv with timeout (polling)
            try:
                coro_func, fut = await asyncio.get_event_loop().run_in_executor(
                    None, queue.recv, 0.1
                )
            except TimeoutError:
                continue
            except Exception:
                # Queue might be closed during shutdown
                break

            if coro_func is None:
                # Sentinel to exit
                break

            async def run_and_store_task():
                try:
                    timeout = getattr(fut, '_timeout', None)

                    async def run_coro():
                        return await coro_func()

                    if timeout is not None:
                        return await spawn(run_coro()).with_timeout(timeout)
                    else:
                        return await coro_func()

                except TaskTimeout:
                    raise TimeoutError()
                except CancelledError:
                    raise asyncio.CancelledError()

            task = await spawn(run_and_store_task())
            task_map[fut] = task

            try:
                result = await task.join()
            except TimeoutError as e:
                fut.set_exception(e)
            except asyncio.CancelledError as e:
                fut.set_exception(e)
            except Exception as e:
                fut.set_exception(e)
            else:
                fut.set_result(result)

            task_map.pop(fut, None)

    async def call_curio(self, coro_func: Callable[[], Any], *, timeout: float | None = None) -> Any:
        loop = asyncio.get_running_loop()
        fut = loop.create_future()
        fut._timeout = timeout # type: ignore

        with self._lock:
            idx = self._next_worker
            self._next_worker = (self._next_worker + 1) % self._workers

        self._queues[idx].send((coro_func, fut))

        try:
            return await asyncio.wait_for(fut, timeout)
        except asyncio.CancelledError:
            task = self._task_maps[idx].get(fut)
            if task:
                def cancel_task():
                    task.cancel()
                from curio.thread import ThreadWorker
                ThreadWorker.schedule(cancel_task)
            raise

    def start(self):
        if self._running:
            return
        self._running = True
        for i in range(self._workers):
            self._shutdown_events[i].clear()
            self._start_worker_thread(i)

    def shutdown(self, wait=True):
        for e in self._shutdown_events:
            e.set()
        for q in self._queues:
            try:
                q.send((None, None))
            except Exception:
                pass

        if wait:
            for t in self._threads:
                if t:
                    t.join()
        self._running = False

    def __enter__(self):
        self.start()
        return self

    def __exit__(self, exc_type, exc_val, exc_tb):
        self.shutdown(wait=True)


async def main():
    async def curio_task():
        import curio
        await curio.sleep(2)
        return "done"

    async with AsyncioCurioBridge(workers=3) as bridge:
        results = await asyncio.gather(
            *(bridge.call_curio(curio_task) for _ in range(10))
        )
        print(results)

asyncio.run(main())
